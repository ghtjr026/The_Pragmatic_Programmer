3장 기본적인 도구

A. 일반 텍스트의 힘
 - 일반 텍스트는 보통 구현에서 직접적으로 유도되는 이진 코딩보다 더 고차원일 때가 많다. 일반 텍스트를 사용하면 그걸 생성하는 애플리케이션에 상관없이 어떤 의미인지 자명한 데이터 흐름을 얻을 수 있다.
 - 지식을 일반 텍스트로 저장하라.

 A-1. 일반 텍스트를 사용하는데 있어서의 단점
  - 압축된 이진 포맷을 사용하는 것보다 더 많은 공간을 차지한다.
  - 일반 텍스트 파일을 해석하고 처리하는데 있어서 더 많은 계산이 필요할 수 있다.
  - 메타 데이터를 일반 텍스트로 저장하면 시스템 사용자에게 노출될지도 모른다는 우려는 잘못된 것이다. 이진 자료가 일반 텍스트에 비해 읽기 어려울 수 있지만 그렇다고 더 안전하지는 않다. 사용자가 암호를 보는 게 걱정된다면 암호를 함호화하고, 사용자가 설정 매개 변수들을 바꾸는 걸 원치 않는다면 모든 매개 변수 값의 보안용 해시를 파일에 체크섬으로 포함시켜라.

 A-2. 텍스트의 힘 ( 장점 )
  A-2-1. 구식이 되는 것에 대한 보험
   - 사람이 읽을 수 있는 형태의 데이터는 어떤 다른 형태의 데이터와 그걸 생성한 애플리케이션보다 더 오래 살아남을 수 있다.
  
  A-2-2. 호환성
  - 컴퓨팅 세계의 거의 모든 도구는 일반 텍스트를 다룰 수 있다.

  A-2-3. 더 쉬운 테스트
   - 특별한 도구를 만들어야 할 필요 없이 간단히 테스트 데이터를 추가, 업데이트, 수정할 수 있다.

 A-3. 최소 공통분모
  - 모든 참가자가 공통의 표준을 사용해서 소통하도록 할 필요가 있다면 일반 테스트가 바로 그 표준이다.

B. 조개 놀이
 - 텍스트 파일을 다루는 프로그래머에게 명령어 셸 ( Shell ) 이 작업대가 될 수 있다.
 - GUI ( Graphical User Interface ) 로 모든 작업을 한다면 가진 환경의 전체 능력을 이용하지 못할 것이며, 도구를 결합해서 자신에게 맞는 매크로 도구를 만들 수 없다.
 - GUI 의 장점 : WYSIWYG ( What you see is what you get )
 - GUI 의 단점 : WYSIAYG ( What you see if all you get )
 - GUI 환경의 기능은 일반적으로 설계자의 의도 따른 제약을 받는다.
 - 셸에 익숙해지면 생산성이 급상승하는 것을 알게 될 것이다.
 - 명령어 셸의 힘을 사용하라.

C. 파워 에디팅
 C-1. 하나의 에디터
  - 에디터 하나를 골라서 완전히 마스터하고, 모든 편집 작업에 그 에디터를 사용하라.
  - 선택한 에디터가 사용하는 모든 플랫폼에서 가능한지 확인하라.
  - 하나의 에디터를 잘 사용하라.

 C-2. 에디터의 기능
  C-2-1. 설정 변경 기능
   - 에디터의 모든 요소 ( 폰트, 색깔, 윈도우 크기, 키입력 바인딩 등 )를 기호에 맞게 다시 설정할 수 있어야 한다.
  
  C-2-2. 확장 기능
   - 어떤 컴파일러 환경과도 결합할 수 있어야 하며, 새로운 언어나 텍스트 포맷 ( XML, HTML 버전 9 등 ) 의 뉘앙스를 ‘가르칠’ 수 있어야 한다.

  C-2-3. 프로그램 기능
   - 복잡하고 다단계의 작업을 수행할 수 있도록 에디터를 프로그램할 수 있어야 한다. 매크로나 내장 스크립팅 프로그래밍 언어를 통해 가능하다.

  C-2-4. 기 외 기능
   - 구문 강조, 자동 완성, 자동 들여쓰기, 코드나 문서 상용어구 지원, IDE 기능 ( 컴파일, 디버깅 등 ) 등

 C-3. 생산성
  - 에디터가 자동으로 템플릿을 제공해 주는 등, 작업을 능률적으로 하는데 있어서 도움을 준다.
  - 자동 들여쓰기 역시 사용자에게 일관된 들여쓰기를 사용할 수 있도록 도움을 준다.

D. 소스코드 관리
 - 소스코드 관리 시스템 혹은 더 넓은 의미의 형상 관리 시스템은 소스코드나 문서 관련의 모든 변화를 기억한다.
 - 적절히 설정된 소스코드 관리 시스템을 쓰면 소프트웨어의 이전 버전으로 언제든 돌아갈 수 있다.
 - 혼자서 프로젝트를 진행하는 경우라도 모든 것이 소스코드 관리 아래에 있도록 하라.
 - 언제나 소스코드 관리 시스템을 사용하라.
 - 제품 빌드를 자동화하고 그것을 반복할 수 있다.

E. 디버깅
 E-1. 디버깅의 심리
  - 디버깅은 단지 문제 해결이라는 사실을 포용하고, 그 방식으로 공략하라.
  - 남을 비난하기보다 문제를 고치는데에 더 집중하라.

 E-2. 디버깅 사고방식
  - 한발짝 뒤로 물러나서 뭣이 자신으로 하여금 버그가 있을 거라고 생각하게 하는지, 그 증후의 원인이 무엇일지 실제로 생각해보는 것이 중요하다.
  - 디버깅할 때 근시를 조심하라. 포면에 보이는 증상만 고치려는 욕구에 저항하라.
  - 실제 문제를 관찰하고 있는 것에서 몇 단계 떨어져 있고, 또 다른 여러 가지와 연관되어 있을 확률이 다분하다.
  - 항상 문제의 근본적인 원인을 발견하려고 노력하고, 그 문제의 특정한 증상만 고치려고 하지 마라.
  - 디버깅할 때 당황하지 마라.

 E-3. 어디에서 시작할까
  - 해당 버그를 살펴보기 전에 깨끗이 컴파일된 코드로 작업하고 있는지 확인하라.
  - 자세한 정보를 얻기 위해서는 해당 버그를 보고한 사용자의 실제 시연을 지켜보는 것도 좋다.
  - 인공테스트는 애플리케이션을 충분히 테스트하지 못한다. 최종 사용자의 사용 패턴 모두를 철저히 테스트해야 한다.

 E-4. 디버깅 전략
  E-4-1. 데이터를 가시화하라.
   - 프로그램이 다루는 데이터를 잘 살펴보고, 데이터 간의 상호관계를 시각화할 수 있는 디버거를 사용하라.

  E-4-2. 트레이싱
   - ‘여기까지 도달’했음을 출력하는 작음 메시지를 말한다.
   - 디버거가 진단할 수 없는 몇 가지 종류의 에러를 진단하는 데에는 특별히 효과적이다.
   - 코드 깊숙이 파고 들어가기 위해 트레이싱 구문을 사용할 수도 있다.
   - 트레이스 메시지는 규칙적이고 일관된 형식이어야 한다.
  
  E-4-3. 고무오리
   - 누군가에게 그걸 설명하는 방법
   - 누군가에게 문제를 설명하게 되면 혼자 코드를 살펴볼 때는 당연히 여기고 지나갈 것을 명시적으로 이야기하게 되며 이 때 새로운 통찰을 얻을 수 있다.

  E-4-4. 제거 과정
   - 써드파트에 문제가 있을 수 있지만, 개발하고 있는 애플리케이션 코드에 버그가 존재할 가능성이 훨씬 더 크다.
   - 문제가 발생한 지점을 찾기 어렵다면 이진탐색과 같이 떨어진 코드 간에 발생하는 곳과 아닌 곳의 차이점을 찾아가면 된다.
   - ‘select’는 망가지지 않았다.

 E-5. 놀람의 요소
  - 버그의 원인이라고 생각하지 못한 부분에서 버그가 있을 수도 있다.
  - 뭔가 예상 못한 ‘놀라운’실패를 대면했을 때 자신이 세운 가정들이 잘못되었다는 것을 깨달아야 한다.
  - 가정하지마라. 증명하라.
  - 놀라운 버그를 마주치면, 단순히 그걸 고치는 것을 넘어서, 왜 이 실패가 더 일찍 발견되지 않았을까 생각하고 다른 테스트를 수정할 필요가 있는지 고려하라.
  - 버그를 고치는데 오래 걸렸다면 왜 그런지 자문하라.
  - 만약 버그가 누군가 잘못내린 결정에 결과였다면 전체 팀과 함께 토론하라.

F. 텍스트 처리
 - 텍스트 처리 언어를 하나 익혀라.
 - 텍스트 처리 언어의 적용범위

 F-1. 텍스트 처리 언어의 적용범위
  - 데이터베이스 스키마 관리
  - 자바 속성 엑세스
  - 테스트 데이터 생성
  - 서적 집필
  - C에서 오브젝트 파스칼 인터페이스로
  - 웹 문서 생성

G. 코드 생성기
 - 코드를 작성하는 코드르 작성하라.

 G-1. 코드 생성기의 두 가지 유형
  - 수동적 코드 생성기 : 결과를 내기 위해 한 번만 실행된다.
  - 능동적 코드 생성기 : 코드 생성이 필요할 때 마다 작동한다. 일회용이라서 언제든지 코드 생서기가 다시 만들어낼 수 있다.

 G-2. 수동적 코드 생성기
  - 타이핑을 줄여준다.
  - 기본적으로 몇 개의 입력에서 주어진 출력을 생성하는 매개 변수화된 템플릿이다.

  G-2-1. 용도
   - 새 소스 파일 생성 : 새로운 파일을 만들 때마다, 템플릿, 소스코드 제어 지시자, 지적재산권 문구, 기본적으로 들어가는 주석을 만들기 위해 사용할 수 있다.
   - 프로그래밍 언어간 일회용 변환을 수행
   - 런타임에 계산하기엔 비용이 많이 드는 참조 테이블과 여타 자원을 생성하기 

 G-3. 능동적 코드 생성기
  - DRY( Don’t Repeat Yourself )원칙을 따르고 싶다면 필수적으로 써야하는 것이다.
  - 능동적 코드 생성기가 있으면 어떤 지식을 단 하나의 형태로만 만들어놓고 애플리케이션이 필요로 하는 온갖 형식으로 변환할 수 있다.

 - 코드 생성기가 꼭 복잡할 필요는 없다.
 - 코드 생성기가 꼭 코드를 생성해야 할 필요는 없다.

---------------------------------------------------

기본적인 도구 정리

일반 텍스트 : 보다 직관적이며 이진 자료보다 안전하지 않는 것은 아니며, 이진 코딩보다 더 고차원일 때가 많다.

Shell : GUI에서 모든 작업을 한다면 가진 환경의 전체 능력을 이용하지 못할 것이며, 도구를 결합해서 자신에게 맞는 매크로 도구를 만들 수 없다. Shell을 사용한다면 생산성이 좋아질 것이다.

에디터 : 하나의 에디터를 마스터하고, 모든 편집 작업에 그 에디터를 사용하는 것이 좋다. 그 전에 선택한 에디터가 사용하는 모든 플렛폼에서 사용 가능한지 확인해야하며, 새로운 환경에서도 사용할 수 있어야 한다.

소스코드 관리 : 관리 시스템을 사용하는 것이 좋다 ( SVN 사용중 )

디버깅 : 문제의 근본적인 원인을 파악해야 하며, 항상 특정한 증상만 고치려고 하지말아야 한다. 데이터의 가시화, 트레이싱 등의 전략을 사용하여 디버깅을 효율적으로 진행해야 하며, 일찍이 발견하지 못 했는지 테스트를 수정해야 하는지 확인해 봐야 한다.

코드 생성기 : 코드 생성기를 사용하라. ( Generator 사용 )

현재 티켓 분석에서 로그 및 코드를 확인하며 문제를 분석하는데 티켓에 대한 문제만 분석하고 있는 것을 더 넓은 시야로 분석하며 처리해야 한다고 생각됨

앞으로 버그 및 코드 수정, 리펙터링 등에서 더 넓은 시야로 문제 파악 및 더 신경써서 코드를 구현해야겠다고 생각됨 ( NTG7 online routing 코드 수정 등 )

----------------------------------------------------