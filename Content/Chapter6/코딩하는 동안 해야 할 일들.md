6장 코딩하는 동안 해야 할 일들

- 코딩은 기계적인 작업이 아니다
- 적극적으로 자기 코드에 대해 생각하지 않는 프로그래머는 우연에 맡기는 프로그래밍을 하는 것이다.

A. 우연에 맡기는 프로그래밍
 - 행운과 어쩌다 오는 성공에 의존하는 프로그래밍을 하지 말아야 한다.
 
 A-1. 프로그래밍을 우연에 맡기면 어떻게 되는가
  - 처음부터 코드가 왜 잘 돌아가는지 모르는 상태에서 이슈가 발생하면 코드가 잘 돌아가지 않을 때 이유를 찾을 수 없다.
  
  A-1-1. 우연적 구현
   - 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일들을 의미한다.
   - 정말로 제대로 돌아가는 것이 아닐지도 모른다. 우리에게만 그런 것처럼 보일 수 있다.
   - 의존하는 조건이 단지 우연인 경우도 있다. 다른 상황에서는 이상하게 작동할지도 모른다.
   - 문서화되지 않는 동작은 라이브러리의 다음 릴리즈에서 변경될 가능성이 있다.
   - 불필요한 추가 호출은 코드를 더 느리게 만든다.
   - 추가로 호출한 루틴 때문에 새로운 버그들이 코드에 들어올 가능성이 있다.

  A-1-2. 우연적 맥락
   - 사용자의 언어가 항상 영어일까? 글자를 읽을 수 있을까?
   - 확실한 것이 아닌 것에 의존하면 안된다.

  A-1-3. 암묵적인 가정
   - 테스팅은 특히 거짓 원인과 우연적인 결과로 가득찬 영역이다.
   - 가정하지 말고, 증명하라.

 - 우연에 맡기는 프로그래밍을 하지 말라.

 A-2. 의도적으로 프로그래밍하기
  - 언제나 자기가 지금 무엇을 하고 있는지 알아야 한다.
  - 맹목적으로 코딩하지 말라. 완전하게 이해하지 못한 애플리케이션을 빌드하려 하거나, 익숙하지 않은 기술을 사용하려고 시도하는 행동은 우연에게 자신을 미혹해도 좋다는 초청장을 보내는 것이다.
  - 계획을 세우고 그것을 바탕으로 진행하라.
  - 신뢰할 수 있는 것에만 기대라. 우연한 일이나 가정에 의존하지 말라.
  - 가정을 문서로 남겨라.
  - 코드만 테스트할 것이 아니라, 새로운 가정도 테스트 해야 한다. 어떤 일이든 실제로 시험해보라.
  - 노력을 기울일 대상의 우선순위를 정하라. 중요한 것들에 먼저 시간을 투자하라.
  - 과거의 노예가 되지마라. 기존 코드가 앞으로 구현할 코드를 지배하도록 하지마라. 더 이상 적절한 코드가 아니라고 생각되면 어떤 코드라도 교체하라.

B. 알고리즘의 속도
 - 빅오표기법
 - 간단한 반복문 : 소진정렬, 배열에서 최댓값 찾기, 체크섬 생성하기
 - 겹친 반복문 : 반복문 안에 반복문이 있는 경우, 버블정렬 등
 - 반씩 잘라 나가기 : 이진 검색, 이진 트리의 순회
 - 나눠서 정복하기 : 퀵 정렬
 - 조합적 : 알고르짐이 항목의 순열을 다루기 시작하면 거의 대부분의 수행시간은 걷잡을 수 없을 정도로 늘어난다.

 - 알고리즘의 차수를 추정하라. 추정을 테스트하라.
 - 적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.
 - 가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다. 입력값의 규모가 작다면 단순한 삽입 정렬과 퀵정렬 간의 큰 차이가 없다.

C. 리팩터링
 C-1. 리팩터링은 언제 해야 하는가
  - 중복 : DRY원칙의 위반을 발견했을 때
  - 직교성이 좋지 않는 설계 : 직교성을 더 좋게 만들 수 있는 코드나 설계를 발견했을 때
  - 유효기간이 끝난 지식 : 뒤쳐진 코드를 보았을 때
  - 성능 : 성능 개선을 위해서는 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 한다.
  - 일찍 리팩터링하고, 자주 리팩터링하라.

 C-2. 리팩터링은 어떻게 하는가
  - 리팩터링의 본질은 재설계이다.
  - 리팩터링과 새로운 기능 추가를 동시에 하지마라.
  - 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다.
  - 단계를 작게 나누어서 신중하게 작업한다.
  - 필드를 한 클래스에서 다른 클래스로 옮기기, 비슷한 메서드를 합쳐서 수퍼클래스로 옮기기 등, 리팩터링에서는 국지적인 변경들이 많이 모여서 커다란 규모의 변화를 낳는 일이 자주 발생한다. 단계를 작게 나누고, 한 단계가 끝날때마다 테스트를 돌린다면, 기나긴 시간의 디버깅 작업을 피할 수 있다.

D. 테스트하기 쉬운 코드
 - 소프트웨어를 만들 때 맨 처음부터 테스트 가능성을 만들어 넣고, 코드를 서로 연결하기 전에 하나하나 철저하게 테스트해야만 한다.
 
 D-1. 단위 테스트
  - 모듈을 통제된 환경에서 철저하게 테스트하고 나면, 더 넓은 환경에서 그 모듈이 어떻게 행동할 것인지 더 감을 잡을 수 있을 것이다.
  - 어떤 모듈에게 이것 저것을 시켜보는 코드를 가리킨다.
  - 단위테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다. 그 다음 반환된 결과들을 이미 알고 있는 값과 비교해보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교해서 올바른지 검사한다.

 D-2. 계약을 잘 지키는지 테스트해보기
  - 어떤 단위가 자기가 맺은 계약을 존중하는지 확실하게 보여주는 테스트 케이스를 작성해야 한다.

 - 모듈을 설계할 때는, 심지어 루틴 하나를 설계할 때도, 그것이 지켜야 할 계약과 계약을 지키는지 테스트하는 코드도 함께 설계해야 한다.
 - 코드를 구현하기 전에 테스트를 먼저 만들어보면, 그 코드의 인터페이스 고정되기 전에 미리 시험해볼 수 있다.
 - 테스트를 염두에 두고 설계하라.

E. 사악한 마법사
 - 마법사는 일방통행 길과 같다. 코드를 만들어 주고, 그걸로 끝이다. 그 코드가 지금 상황에 맞지 않는다면, 또는 상황이 바뀌어서 코드를 변경해야할 필요가 생긴다면 혼자 힘으로 해야 한다.
 - 마법사가 만들어준 코드르 이해해야 하며, 이해하지 못했다면, 그 애플리케이션을 유지보수하지도 못할 것이고, 디버깅할 때 고생할 것이다.
 - 자신이 이해하지 못하는, 마법사가 만들어준 코드는 사용하지 말라.

----------------------------------------------

코드를 구현할 때 항상 생각을 하고 구현하되, 이미 구현된 코드를 이해하고 수정해야 한다.

설계 / 구현에 있어서 테스트를 염두에 두고 구현해야 하며, 구현된 코드는 테스트를 반드시 진행해야 한다. 이해하지 못한 코드를 변경하는 것은 이슈가 발생했을 때 수정할 때 많은 시간이 든다.

------------------------------------------------------------