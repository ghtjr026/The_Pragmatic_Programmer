4장 실용주의 편집증
 - 완벽한 소프트웨어는 만들 수 없다.

A. 계약에 의한 설계
 - 정직한 거래를 보장하는 최선의 해법 중 하나는 계약이다.
 - 계약은 상대편은 물론 자신의 권리와 책임을 정의한다. 뿐만 아니라 한쪽이 계약을 어겼을 경우의 손해에 대해서도 계약 사항에 포함된다.
 - 정확한 프로그램이란, 스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그 만큼만 하는 프로그램을 말한다.
 - 계약에 의한 설계 ( DBC : Design By Contract )

 A-1. 선행조건
  - 루틴이 호출되기 위해 참이어야 하는 것.
  - 루틴의 요구사항.
  - 루틴의 선행조건이 위반된 경우에는 루틴이 호출되어서는 안된다.
  - 제대로된 데이터를 전달하는 것은 호출하는 쪽의 책임이다.

 A-2. 후행조건
  - 루틴이 자기가 할 것이라고 보장하는 것.
  - 루틴이 완료되었을 때 세상의 상태
  - 루틴에 후행조건이 있다는 것은 곧 그것이 중국에는 종료될 것이라는 것을 암시한다.
  - 무한 반복은 허용되지 않는다.

 A-3. 클래스 불변식
  - 호출자의 입장에서 볼 때는 이 조건이 언제나 참이라고 클래스가 보장된다.
  - 루틴의 내부 처리 중에는 제어권이 반환될 때에는 불변식이 참이어야 한다.

 - 무슨 일이 벌어지는 간에 계약에 부응하지 못하는게 버그가 되어버리는 실수는 저지르지 마라.
 - 계약에 따른 설계를 하라.
 - ‘게으른 코드’를 짜라.
 - 시작하기 전에 자신이 수용할 것에 대해서는 엄격하게 하고, 내어줄 것에 대해서는 최소한도를 약속하는 것이다.
 - 리스코프 대체 원칙 ( Liskov Substitution Principle ) : 서브클래스는 사용자가 차이점을 모르고서도 기반 클래스 인터페이스를 통해 사용할 수 있어야 한다.

B. 죽은 프로그램은 거짓말을 하지 않는다.
 - ‘그런 일은 절대 일어날 리 없어’라는 사고에 빠지기 쉽다.
 - 모든 에러는 정보를 준다.
 - 만약 에러가 있다면 정말로 뭔가 나쁜 일이 생긴 것이라고 자신에게 이야기한다.
 - 일찍 작동을 멈추게 하라.
 
 B-1. 망치지 말고 멈추라.
  - 가능한 한 빨리 문제를 발견하게 되면, 좀 더 일찍 시스템을 멈출 수 있다.
  - 불가능한 뭔가가 발생했다는 것을 코드가 발견한다면, 프로그램은 더 이상 유효하지 않다고 할 수 있다.
  - 이 시점 이후로 하는 일은 모두 수상쩍은 일이므로, 되도록 빨리 종료해야 한다.

C. 단정적 프로그래밍
 - 단정문을 사용해서 불가능한 상황을 예방하라.
 - ‘그런 일은 일어나지 않을 거야’라는 생각이 든다면, 그걸 확인하는 코드를 추가하라. 가장 간단한 방법은 단정문을 사용하는 것이다.
 - assert와 같은 매크로를 사용하라.

 C-1. 단정 기능을 켜둬라.
  C-1-1. 단정에 대한 오해
   - ‘단정은 코드에 과부화를 준다. 단정은 결코 일어날 수 없는 것들을 검사하기 때문에 코드 속 버그에 의해서만 촉발될 것이다.’
   - ‘일단 코드가 테스트되고 선적된 다음에는 더 이상 단정이 필요하지 않고, 코드 실행이 빨라지도록 단정을 꺼버려야 한다. 단정은 디버깅 도구일 뿐이다.’

  C-1-2. 잘못된 가정들
   - 테스트가 모든 버그를 발견할 수 없다.
   - 낙관주의자들은 프로그램이 험한 세상에서 돌아간다는 사실을 잊는다.

 - 퍼포먼스에 문제가 있더라도, 정말 문제가 되는 단정문만 끄도록 하라.

D. 언제 예외를 사용할까
 
 D-1. 무엇이 예외적인가
  - 예외는 의외의 상황을 위해 남겨두어야 한다.
  - e.g. 코드가 어떤 파일을 열어 읽으려고 함
  - 파일이 반드시 존재해야 하는 경우라면 ‘예외’를 발생시키고, 아니라면 에러를 발생시칸다.
  - 예외는 예외적인 문제에 사용하라.
  - 예외가 있다는 것은 컨트롤의 이동이 즉각적이고 로컬하지 않다는 것을 말한다.
  - 예외를 정상적인 처리 과정의 일부로 사용하는 프로그램은 가독성 문제, 관리성 문제를 떠안게 되며, 캡슐화를 깨뜨릴 수 있고 루틴과 그 호출자들 사이의 결합도가 높아져 버린다.

 D-2. 에러 처리기는 또 다른 대안이다.
  - 에러 처리기는 에러가 감지되었을 때 호출되는 루틴이다.
  - 특정 부류의 에러를 처리하기 위해 어떤 루틴을 등록하게 되며, 해당하는 에러가 났을 때 그 처리기가 호출 될 것이다.

E. 리소스 사용의 균형
 - 시작한 것은 끝내라
 - 단순히 리소스를 할당하는 루틴이나 객체가 리소스를 해제하는 책임을 져야한다는 의미가 아니며, 이상적으로 말해서 리소스를 할당하는 루틴이 해제 역시 책임져야 한다는 의미이다.

 E-1. 중첩할당
  - 리소스를 할당한 순서의 반대로 해제하라. 이렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.
  - 코드의 여러곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게 해야 deadlock의 가능성이 줄어들 것이다.

 E-2. 객체와 예외
  - 할당과 해제의 균형은 클래스의 생성자와 소멸자를 생각나게 한다.
  - 클래스는 하나의 리소스를 대표하며, 생성자는 그 리소스 타입의 특정 객체를 제공하고, 소멸자는 그것을 현재 범위에서 제거한다.

 E-3. 균형과 예외
  - 예외를 지원하는 언어는 리소스 해제에 복잡한 문제가 있을 수 있다.

  E-3-1. 예외가 던져진 경우, 그 예외 이전에 할당된 모든 것이 깨끗이 청소된다고 보장할 수 있는 경우
   - Java : 가비지콜렉션을 사용하여 게으른 방식의 자동 객체 삭제를 사용
   - 가비지콜렉션이 객체를 지우려고 하기만 한다면, 객체의 finalize 메소드가 호출될 것이다.
   - 참고 : java에서 객체가 소멸될 때 호출되기로 약속된 메소드

 - try 블록에 finally 절이 있다면, 그 정 안의 코드들은 try 블록 안의 코드가 한 문장이라도 실행되면 반드시 실행되도록 되어있다.
 - finally 절 안의 코드는 반드시 실행되기 때문에 이 코드를 사용해서 리소스 사용의 균형을 잡을 수 있다.

 E-4. 리소스 사용의 균형을 잡을 수 없는 경우
  - 동적 자료 구조형을 사용하는 경우 기본적인 리소스 할당 방식에 적절하지 않다.

  E-4-1. 최상위 구조의 할당을 해제하는 경우, 선택할 수 있는 방식
   - 최상의 구조 자신이 자기 안에 들어있는 하위 구조들의 할당을 해제할 책임이 있으며, 하위 구조들은 또 다시 재귀적으로 자기 안에 들어있는 자료들을 해체하고 ...
   - 최상위 구조에서 그냥 할당이 해제된다. 그 안에서 참조하던 구조들은 모두 연결이 끊어져 고아가 된다.
   - 최상위 구조는 하나라도 하위 구조를 가지고 있을 경우 자기의 할당 해제를 거부한다.

 E-5. 균형을 점검하기
  - 정말로 리소스가 적절하게 해제되었는지 실제로 점검하는 코드를 작성하는 것이 좋다.

--------------------------------------------------------

단정문 : 단정문을 사용하여 불가능한 상황을 예방해야 하며, ‘그런 일은 일어나지 않을거야’라는 생각이 든다면 단정문을 추가하는 것이 바람직하다.

예외 및 에러 처리기 : 예외의 상황을 위해 남겨두는 코드로, 반드시 동작해야 하는 코드라면 예외를 발생시키고, 아니라면 에러를 발생시킨다.

리로스 사용 : 리소스를 할당했다면, 반드시 해제해야 하며, 해제시 deadlock 가능성을 조심해야 한다.


단정문은 사용하면 안되며, 멈추면 안되는 시스템이기 때문이다. 예외는 구현할 때 신경써야 하는 부분이며, 유지보수에도 놓친 예외는 없는지 확인이 필요하다. new – delete의 짝이 맞아야하며 순서도 중요하다.

--------------------------------------------------------